<!DOCTYPE html><html lang="en"><head>
    
    
    <meta charset="utf-8">
    
      <title>Untangling cycles - lottia notes</title>
      <meta property="og:title" content="Untangling cycles">
      <meta property="og:site_name" content="lottia notes">
      <meta property="og:description" content="Wherein the author perceives time in multiple lights, simultaneously, and logic does too, but, uh, differently.">
    
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="website">

    <meta name="author" content="Asherah Connor">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" href="stylesheet.css?v=1">
    <link rel="stylesheet" href="syntax.css">

    
      <link href="atom.xml" rel="alternate" title="lottia notes" type="application/atom+xml">
    
    <meta name="generator" content="Nanoc 4.12.16">
  </head>
  <body id="top">
    <div class="flex">
      <main>
        <h1>Untangling cycles</h1>
        
          <p>
            <span class="created-at">2023-06-29</span>
            
          </p>
        
        <p>This is straight from my journal, so it starts without warning.</p>
<hr>
<p>The bit packing is turning out to be surprisingly tricky!</p>
<p>Memory is synchronous but our uses of <code>addr[0]</code> were all comb, so they didn’t
align with the actual target in the cycle it got transmitted from memory when we
were advancing <code>addr</code> every cycle. This was a really good exercise in Being
Confused As Heck.</p>
<p>Going to try to explicate the above a bit more clearly for my own elucidation.
Ignoring the write half of the equation for simplicity—the issues faced are the
same.</p>
<p>This post is literate Python. Why not. We have the following as baseline:</p>
<pre><code class="language-python"><span class="kn">import</span> <span class="n">math</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>

<span class="kn">from</span> <span class="n">amaranth</span> <span class="kn">import</span> <span class="n">Elaboratable</span><span class="p">,</span> <span class="n">Memory</span><span class="p">,</span> <span class="n">Module</span><span class="p">,</span> <span class="n">Record</span><span class="p">,</span> <span class="n">Signal</span>
<span class="kn">from</span> <span class="n">amaranth.build</span> <span class="kn">import</span> <span class="n">Platform</span>
<span class="kn">from</span> <span class="n">amaranth.hdl.ast</span> <span class="kn">import</span> <span class="n">ShapeCastable</span>
<span class="kn">from</span> <span class="n">amaranth.hdl.mem</span> <span class="kn">import</span> <span class="n">ReadPort</span>
<span class="kn">from</span> <span class="n">amaranth.hdl.rec</span> <span class="kn">import</span> <span class="n">DIR_FANIN</span><span class="p">,</span> <span class="n">DIR_FANOUT</span>
<span class="kn">from</span> <span class="n">amaranth.sim</span> <span class="kn">import</span> <span class="n">Simulator</span>


<span class="k">class</span> <span class="nc">ROMBus</span><span class="p">(</span><span class="n">Record</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">addr</span><span class="p">:</span> <span class="n">ShapeCastable</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">ShapeCastable</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="sh">"</span><span class="s">addr</span><span class="sh">"</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">DIR_FANIN</span><span class="p">),</span>
                <span class="p">(</span><span class="sh">"</span><span class="s">data</span><span class="sh">"</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">DIR_FANOUT</span><span class="p">),</span>
            <span class="p">],</span>
            <span class="n">name</span><span class="o">=</span><span class="sh">"</span><span class="s">ROMBus</span><span class="sh">"</span><span class="p">,</span>
        <span class="p">)</span>

<span class="k">class</span> <span class="nc">Downstream</span><span class="p">(</span><span class="n">Record</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="sh">"</span><span class="s">data</span><span class="sh">"</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">DIR_FANIN</span><span class="p">),</span>
                <span class="p">(</span><span class="sh">"</span><span class="s">stb</span><span class="sh">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">DIR_FANIN</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span></code></pre>
<p>A <code>ROMBus</code> is a connectable path to access some read-only memory. <code>Downstream</code>
here is a hypothetical recipient of data being read from ROM. (The ROM is
actually a RAM that gets filled on power-on from flash.)</p>
<p>The key problem I was solving was that, until now, I’ve been storing all my data
in 8-bit wide <code>Memory</code> instances, but a lot of the actual embedded block RAM I’m
using has 16-bit wide words. As a result, the upper 8 bits of every word has
been left unused.</p>
<p>It’d be nice to add a translation layer that transparently forwarded reads and
writes from an 8-bit addressable space into the 16-bit words. Even bytes in the
lower halves, odd bytes in the upper halves. Here’s what that’d look like:</p>
<pre><code class="language-python"><span class="n">ROM_CONTENT_PACKED</span> <span class="o">=</span> <span class="p">[</span><span class="mh">0x2211</span><span class="p">,</span> <span class="mh">0x4433</span><span class="p">,</span> <span class="mh">0x6655</span><span class="p">,</span> <span class="mh">0x8877</span><span class="p">]</span>
<span class="n">ROM_LENGTH</span> <span class="o">=</span> <span class="mi">8</span></code></pre>
<p>The length of the ROM that all the downstream consumers care about is the 8-bit
addressable one—address 0 has <code>0x11</code>, address 1 <code>0x22</code>, etc. The fact that we
have 8 bytes packed into 4 words of 16 bits is irrelevant to them.</p>
<p>Here’s where our example will play out:</p>
<pre><code class="language-python"><span class="k">class</span> <span class="nc">Example</span><span class="p">(</span><span class="n">Elaboratable</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">downstream</span> <span class="o">=</span> <span class="nc">Downstream</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">elaborate</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">platform</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Platform</span><span class="p">]):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nc">Module</span><span class="p">()</span></code></pre>
<p>The <code>Downstream</code> is exposed on the instance so we can access it from our
simulator process.</p>
<p>We now need to do the following things:</p>
<ul>
<li>Determine the size of the packed RAM.</li>
<li>Create our <code>Memory</code> instance for it.
<ul>
<li>We’ll initialize it with <code>init</code> here, and completely ignore the write
aspect of the scenario. The issues it will suffer from are the same. (I
sure suffered!)</li>
</ul>
</li>
<li>Get the <code>ReadPort</code> for our RAM. I’m asserting the lengths here illustratively for the reader’s benefit.</li>
</ul>
<pre><code class="language-python">        <span class="n">packed_size</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">ceil</span><span class="p">(</span><span class="n">ROM_LENGTH</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">rom_mem</span> <span class="o">=</span> <span class="nc">Memory</span><span class="p">(</span>
            <span class="n">width</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
            <span class="n">depth</span><span class="o">=</span><span class="n">packed_size</span><span class="p">,</span>
            <span class="n">init</span><span class="o">=</span><span class="n">ROM_CONTENT_PACKED</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">m</span><span class="p">.</span><span class="n">submodules</span><span class="p">.</span><span class="n">rom_rd</span> <span class="o">=</span> <span class="n">rom_rd</span> <span class="o">=</span> <span class="n">rom_mem</span><span class="p">.</span><span class="nf">read_port</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">rom_rd</span><span class="p">.</span><span class="n">addr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">rom_rd</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">16</span></code></pre>
<p><code>rom_rd.addr</code> determines the address in the 16-bit-wide RAM (<code>0x0</code>–<code>0x3</code>), and
<code>rom_rd.data</code> returns those 16 bits. <code>Memory</code> is <a href="https://github.com/amaranth-lang/amaranth/blob/99417d6499b006a172d5b8cba413fd6181737374/amaranth/hdl/mem.py#L153">synchronous by
default</a>
(and the read enable is also <a href="https://github.com/amaranth-lang/amaranth/blob/99417d6499b006a172d5b8cba413fd6181737374/amaranth/hdl/mem.py#L165-L169">always on under default
settings</a>),
so, given a made-up <code>mem[x]</code> operator, the following timeline applies:</p>
<ul>
<li>cycle <em>n</em>+0: some process assigns <code>rom_rd.addr.eq(x)</code>
</li>
<li>cycle <em>n</em>+1: the read port sees its new <code>addr</code> value and assigns
<code>rom_rd.data.eq(mem[x])</code>
</li>
<li>cycle <em>n</em>+2: <code>rom_rd.data</code> takes the value of <code>mem[x]</code>
</li>
</ul>
<p>Now we’ll create our <code>ROMBus</code>. This is what all the RTL I had was already
using—it was connected directly to the read port of the 8-wide memory.</p>
<pre><code class="language-python">        <span class="n">rom_bus</span> <span class="o">=</span> <span class="nc">ROMBus</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">ROM_LENGTH</span><span class="p">),</span> <span class="mi">8</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">rom_bus</span><span class="p">.</span><span class="n">addr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">rom_bus</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8</span></code></pre>
<p>We’re going to put the actual translation logic and state machine in separate
functions, so they can be changed later while preserving the literacy of this
post. <em>Why not</em>.</p>
<pre><code class="language-python">        <span class="n">self</span><span class="p">.</span><span class="nf">translation</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">rom_rd</span><span class="p">,</span> <span class="n">rom_bus</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">fsm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">rom_bus</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">m</span></code></pre>
<p>We want to hook up the ROM bus to the memory in a transparent fashion. Here’s
what I started with:</p>
<pre><code class="language-python">    <span class="k">def</span> <span class="nf">translation</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">Module</span><span class="p">,</span> <span class="n">rom_rd</span><span class="p">:</span> <span class="n">ReadPort</span><span class="p">,</span> <span class="n">rom_bus</span><span class="p">:</span> <span class="n">ROMBus</span><span class="p">):</span>
        <span class="n">m</span><span class="p">.</span><span class="n">d</span><span class="p">.</span><span class="n">comb</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="n">rom_rd</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="n">rom_bus</span><span class="p">.</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">rom_bus</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span>
                <span class="n">rom_rd</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">word_select</span><span class="p">(</span><span class="n">rom_bus</span><span class="p">.</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">8</span><span class="p">)</span>
            <span class="p">),</span>
        <span class="p">]</span></code></pre>
<ul>
<li>
<p>We shift off the last bit of the input (8-bit) address to create the output
(16-bit) address, creating the following mapping:</p>
<table>
<thead>
<tr>
<th align="right">8-bit address</th>
<th align="right">16-bit address</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">
<code>0x0</code> / <code>0b000</code>
</td>
<td align="right">
<code>0x0</code> / <code>0b00</code>
</td>
</tr>
<tr>
<td align="right">
<code>0x1</code> / <code>0b001</code>
</td>
<td align="right">
<code>0x0</code> / <code>0b00</code>
</td>
</tr>
<tr>
<td align="right">
<code>0x2</code> / <code>0b010</code>
</td>
<td align="right">
<code>0x1</code> / <code>0b01</code>
</td>
</tr>
<tr>
<td align="right">
<code>0x3</code> / <code>0b011</code>
</td>
<td align="right">
<code>0x1</code> / <code>0b01</code>
</td>
</tr>
<tr>
<td align="right">
<code>0x4</code> / <code>0b100</code>
</td>
<td align="right">
<code>0x2</code> / <code>0b10</code>
</td>
</tr>
<tr>
<td align="right">
<code>0x5</code> / <code>0b101</code>
</td>
<td align="right">
<code>0x2</code> / <code>0b10</code>
</td>
</tr>
<tr>
<td align="right">
<code>0x6</code> / <code>0b110</code>
</td>
<td align="right">
<code>0x3</code> / <code>0b11</code>
</td>
</tr>
<tr>
<td align="right">
<code>0x7</code> / <code>0b111</code>
</td>
<td align="right">
<code>0x3</code> / <code>0b11</code>
</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>We select the 8-bit word from the 16-bit data coming out of the memory corresponding to the LSB of the input (8-bit) address.</p>
<ul>
<li>
<code>a.word_select(b, w)</code> is essentially <code>a[b*w : (b+1)*w]</code>.</li>
<li>When the LSB of the 8-bit address is 0, this will select <code>rd_data[0:8]</code>.
When the LSB is 1, this will select <code>rd_data[8:16]</code>.</li>
<li>So:
<ul>
<li>8-bit address <code>0x0</code> will select <code>mem[0x0][0:8]</code>,</li>
<li>8-bit address <code>0x1</code> will select <code>mem[0x0][8:16]</code>,</li>
<li>8-bit address <code>0x2</code> will select <code>mem[0x1][0:8]</code>,</li>
<li>8-bit address <code>0x3</code> will select <code>mem[0x1][8:16]</code>,</li>
<li>etc.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Now we implement a reader from our ROM:</p>
<pre><code class="language-python">    <span class="k">def</span> <span class="nf">fsm</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">Module</span><span class="p">,</span> <span class="n">rom_bus</span><span class="p">:</span> <span class="n">ROMBus</span><span class="p">):</span>
        <span class="n">m</span><span class="p">.</span><span class="n">d</span><span class="p">.</span><span class="n">sync</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">downstream</span><span class="p">.</span><span class="n">stb</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">m</span><span class="p">.</span><span class="nc">FSM</span><span class="p">():</span>
            <span class="k">with</span> <span class="n">m</span><span class="p">.</span><span class="nc">State</span><span class="p">(</span><span class="sh">"</span><span class="s">INITIAL</span><span class="sh">"</span><span class="p">):</span>
                <span class="c1"># cycle n+0
</span>                <span class="n">m</span><span class="p">.</span><span class="n">d</span><span class="p">.</span><span class="n">sync</span> <span class="o">+=</span> <span class="n">rom_bus</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">m</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="sh">"</span><span class="s">WAIT</span><span class="sh">"</span>

            <span class="k">with</span> <span class="n">m</span><span class="p">.</span><span class="nc">State</span><span class="p">(</span><span class="sh">"</span><span class="s">WAIT</span><span class="sh">"</span><span class="p">):</span>
                <span class="c1"># cycle n+1 / n'+1
</span>                <span class="n">m</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="sh">"</span><span class="s">READ</span><span class="sh">"</span>

            <span class="k">with</span> <span class="n">m</span><span class="p">.</span><span class="nc">State</span><span class="p">(</span><span class="sh">"</span><span class="s">READ</span><span class="sh">"</span><span class="p">):</span>
                <span class="c1"># cycle n+2, n'+0
</span>                <span class="n">m</span><span class="p">.</span><span class="n">d</span><span class="p">.</span><span class="n">sync</span> <span class="o">+=</span> <span class="p">[</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">downstream</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="n">rom_bus</span><span class="p">.</span><span class="n">data</span><span class="p">),</span>
                    <span class="n">self</span><span class="p">.</span><span class="n">downstream</span><span class="p">.</span><span class="n">stb</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                    <span class="n">rom_bus</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="n">rom_bus</span><span class="p">.</span><span class="n">addr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                <span class="p">]</span>
                <span class="n">m</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="sh">"</span><span class="s">WAIT</span><span class="sh">"</span></code></pre>
<p>This is a simple process that reads data and passes them along to some
downstream process (which needs to be able to accept this data as fast as we
give it to them!).</p>
<ul>
<li>We start at address zero (<em>n</em>+0),</li>
<li>wait a cycle for the memory to see it (<em>n</em>+1),</li>
<li>and then pass it to the downstream (<em>n</em>+2) while advancing the address we read
(<em>n</em>’+0).</li>
<li>The next cycle we’re back in <code>WAIT</code> as advanced address is seen by the memory
(<em>n</em>’+1).</li>
</ul>
<p>We end up strobing the downstream every other cycle. (That strobe is seen in the
<em>n</em>+1 / <em>n</em>’+1 cycle.)</p>
<p>Let’s simulate it and report the results:</p>
<pre><code class="language-python"><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">dut</span> <span class="o">=</span> <span class="nc">Example</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">process</span><span class="p">():</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">yield</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="nf">if </span><span class="p">(</span><span class="k">yield</span> <span class="n">dut</span><span class="p">.</span><span class="n">downstream</span><span class="p">.</span><span class="n">stb</span><span class="p">):</span>
                <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">data: </span><span class="si">{</span><span class="p">(</span><span class="k">yield</span> <span class="n">dut</span><span class="p">.</span><span class="n">downstream</span><span class="p">.</span><span class="n">data</span><span class="p">)</span><span class="si">:</span><span class="mi">02</span><span class="n">x</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                    <span class="k">return</span>
            <span class="k">yield</span>

    <span class="n">sim</span> <span class="o">=</span> <span class="nc">Simulator</span><span class="p">(</span><span class="n">dut</span><span class="p">)</span>
    <span class="n">sim</span><span class="p">.</span><span class="nf">add_clock</span><span class="p">(</span><span class="mf">1e-6</span><span class="p">)</span>
    <span class="n">sim</span><span class="p">.</span><span class="nf">add_sync_process</span><span class="p">(</span><span class="n">process</span><span class="p">)</span>
    <span class="n">sim</span><span class="p">.</span><span class="nf">run</span><span class="p">()</span></code></pre>
<p>This can now be run:</p>
<pre><code class="language-console"><span class="gp">$</span><span class="w"> </span>python <span class="nt">-c</span> <span class="s1">'import ex; ex.main()'</span>
<span class="go">data: 11
data: 22
data: 33
data: 44
data: 55
data: 66
data: 77
data: 88</span></code></pre>
<p>It’s perfect!</p>
<p>Almost. Let’s revisit the timeline for accessing the synchronous memory:</p>
<ul>
<li>cycle <em>n</em>+0: <code>rom_rd.addr.eq(x)</code>
</li>
<li>cycle <em>n</em>+1: read port sees new <code>addr</code>, assigns <code>rom_rd.data.eq(mem[x])</code>
</li>
<li>cycle <em>n</em>+2: <code>rom_rd.data</code> sees <code>mem[x]</code>
</li>
</ul>
<p>The important part is that you can assign a new address <code>y</code> in cycle <em>n</em>+1,
without impacting what happens in cycle <em>n</em>+2, such that <code>mem[y]</code> is now
available to use in cycle <em>n</em>+3. The read port will only see the address <code>y</code> in
the same cycle that it’s already propagated <code>mem[x]</code> into its data register.</p>
<p>Let’s now change our state machine to take advantage of this:</p>
<pre><code class="language-python"><span class="k">def</span> <span class="nf">fsm</span><span class="p">(</span><span class="n">self</span><span class="p">:</span> <span class="n">Example</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">Module</span><span class="p">,</span> <span class="n">rom_bus</span><span class="p">:</span> <span class="n">ROMBus</span><span class="p">):</span>
    <span class="n">m</span><span class="p">.</span><span class="n">d</span><span class="p">.</span><span class="n">sync</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">downstream</span><span class="p">.</span><span class="n">stb</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">m</span><span class="p">.</span><span class="nc">FSM</span><span class="p">():</span>
        <span class="k">with</span> <span class="n">m</span><span class="p">.</span><span class="nc">State</span><span class="p">(</span><span class="sh">"</span><span class="s">INITIAL</span><span class="sh">"</span><span class="p">):</span>
            <span class="c1"># cycle n+0
</span>            <span class="n">m</span><span class="p">.</span><span class="n">d</span><span class="p">.</span><span class="n">sync</span> <span class="o">+=</span> <span class="n">rom_bus</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">m</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="sh">"</span><span class="s">WAIT</span><span class="sh">"</span>

        <span class="k">with</span> <span class="n">m</span><span class="p">.</span><span class="nc">State</span><span class="p">(</span><span class="sh">"</span><span class="s">WAIT</span><span class="sh">"</span><span class="p">):</span>
            <span class="c1"># cycle n+1, n'+0
</span>            <span class="n">m</span><span class="p">.</span><span class="n">d</span><span class="p">.</span><span class="n">sync</span> <span class="o">+=</span> <span class="n">rom_bus</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">m</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="sh">"</span><span class="s">READ</span><span class="sh">"</span>

        <span class="k">with</span> <span class="n">m</span><span class="p">.</span><span class="nc">State</span><span class="p">(</span><span class="sh">"</span><span class="s">READ</span><span class="sh">"</span><span class="p">):</span>
            <span class="c1"># cycle n+2, n'+1, n''+0
</span>            <span class="n">m</span><span class="p">.</span><span class="n">d</span><span class="p">.</span><span class="n">sync</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">self</span><span class="p">.</span><span class="n">downstream</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="n">rom_bus</span><span class="p">.</span><span class="n">data</span><span class="p">),</span>
                <span class="n">self</span><span class="p">.</span><span class="n">downstream</span><span class="p">.</span><span class="n">stb</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                <span class="n">rom_bus</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="n">rom_bus</span><span class="p">.</span><span class="n">addr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
            <span class="p">]</span>


<span class="n">Example</span><span class="p">.</span><span class="n">fsm</span> <span class="o">=</span> <span class="n">fsm</span></code></pre>
<ul>
<li>We start at address zero (<em>n</em>+0),</li>
<li>while waiting a cycle for the memory to see it (<em>n</em>+1), we also increment the
address to one (<em>n</em>’+0),</li>
<li>and then pass the first result the downstream (<em>n</em>+2), while the memory is
just now seeing the second result (<em>n</em>’+1), and simultaneously increment the
address we read (<em>n</em>’’+0).</li>
</ul>
<p>We don’t change state once we’re in <code>READ</code>: every cycle we hand to downstream
the data from the address we set two cycles ago; every cycle the memory is
seeing the address we gave one cycle ago; every cycle we increment the address
to keep it going.</p>
<p>(My wording here muddles up the timing of when we “set” a given value quite a
lot — really, we <em>initiate</em> the setting of the address two cycles ago, which one
cycle ago <em>is</em> set (and seen), which this cycle we then see the data returned
of.)</p>
<p>This is pretty theoretical in this form, but I have a few state machines that do
this kind of sliding continuous read in a limited fashion.</p>
<p>So what happens?</p>
<pre><code class="language-console"><span class="gp">$</span><span class="w"> </span>python <span class="nt">-c</span> <span class="s1">'import ex; ex.main()'</span>
<span class="go">data: 22
data: 11
data: 44
data: 33
data: 66
data: 55
data: 88
data: 77</span></code></pre>
<p>All the bytes are reversed! (This was a <em>lot</em> weirder to debug when the same
problem might have been affecting the initial write to RAM, too.)</p>
<p>Why?</p>
<p>We’ll review the translation statements:</p>
<pre><code class="language-python"><span class="n">m</span><span class="p">.</span><span class="n">d</span><span class="p">.</span><span class="n">comb</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="n">rom_rd</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="n">rom_bus</span><span class="p">.</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">rom_bus</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span>
        <span class="n">rom_rd</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">word_select</span><span class="p">(</span><span class="n">rom_bus</span><span class="p">.</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">8</span><span class="p">)</span>
    <span class="p">),</span>
<span class="p">]</span></code></pre>
<p>This translation happens in the combinatorial domain, meaning that <code>rom_rd.addr</code>
will change to <code>rom_bus.addr &gt;&gt; 1</code> as soon as a change on <code>rom_bus.addr</code> is
registered — there isn’t an additional cycle between the requested 8-bit address
on the ROM bus changing and the read port’s 16-bit address changing:</p>
<table>
<thead>
<tr>
<th align="right">cycle</th>
<th align="right">statement issued</th>
<th align="right">
<nobr>ROM bus</nobr> addr</th>
<th align="right">
<nobr>read port</nobr> addr</th>
<th align="right">
<nobr>read port</nobr> data</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">0</td>
<td align="right"><code>rom_bus.addr.eq(0)</code></td>
<td align="right"><em>x</em></td>
<td align="right"><em>x</em></td>
<td align="right"><em>x</em></td>
</tr>
<tr>
<td align="right">1</td>
<td align="right"><code>rom_bus.addr.eq(1)</code></td>
<td align="right"><code>0</code></td>
<td align="right"><code>0</code></td>
<td align="right"><em>x</em></td>
</tr>
<tr>
<td align="right">2</td>
<td align="right"><code>rom_bus.addr.eq(2)</code></td>
<td align="right"><code>1</code></td>
<td align="right"><code>0</code></td>
<td align="right"><code>0x2211</code></td>
</tr>
<tr>
<td align="right">3</td>
<td align="right"><code>rom_bus.addr.eq(3)</code></td>
<td align="right"><code>2</code></td>
<td align="right"><code>1</code></td>
<td align="right"><code>0x2211</code></td>
</tr>
<tr>
<td align="right">4</td>
<td align="right"><code>rom_bus.addr.eq(4)</code></td>
<td align="right"><code>3</code></td>
<td align="right"><code>1</code></td>
<td align="right"><code>0x4433</code></td>
</tr>
<tr>
<td align="right">5</td>
<td align="right"><code>rom_bus.addr.eq(5)</code></td>
<td align="right"><code>4</code></td>
<td align="right"><code>2</code></td>
<td align="right"><code>0x4433</code></td>
</tr>
</tbody>
</table>
<p>Similarly, the ROM bus data port will be updated as soon as the read port’s data
port (<code>rom_rd.data</code>) changes.</p>
<p>It will <em>also</em> be updated as soon as the LSB of the ROM bus’s requested address
changes (<code>rom_bus.addr[0]</code>).</p>
<p>But by the time we’re actually getting data in the read port for an address, the
ROM bus has registered the next address!  Thus we select the half of the 16-bit
word based on the LSB of the <em>following</em> address, which (given the addresses are
sequential) will always be the opposite half to the one we really want:</p>
<table>
<thead>
<tr>
<th align="right">cycle</th>
<th align="right">
<nobr>ROM bus</nobr> addr</th>
<th align="right">
<nobr>read port</nobr> data</th>
<th align="right">
<nobr>ROM bus</nobr> <nobr>addr [0]</nobr>
</th>
<th align="right">
<nobr>ROM bus</nobr> data</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">0</td>
<td align="right"><em>x</em></td>
<td align="right"><em>x</em></td>
<td align="right"><em>x</em></td>
<td align="right"><em>x</em></td>
</tr>
<tr>
<td align="right">1</td>
<td align="right"><code>0</code></td>
<td align="right"><em>x</em></td>
<td align="right"><code>0</code></td>
<td align="right"><em>x</em></td>
</tr>
<tr>
<td align="right">2</td>
<td align="right"><code>1</code></td>
<td align="right"><code>0x2211</code></td>
<td align="right"><code>1</code></td>
<td align="right"><code>0x22</code></td>
</tr>
<tr>
<td align="right">3</td>
<td align="right"><code>2</code></td>
<td align="right"><code>0x2211</code></td>
<td align="right"><code>0</code></td>
<td align="right"><code>0x11</code></td>
</tr>
<tr>
<td align="right">4</td>
<td align="right"><code>3</code></td>
<td align="right"><code>0x4433</code></td>
<td align="right"><code>1</code></td>
<td align="right"><code>0x44</code></td>
</tr>
<tr>
<td align="right">5</td>
<td align="right"><code>4</code></td>
<td align="right"><code>0x4433</code></td>
<td align="right"><code>0</code></td>
<td align="right"><code>0x33</code></td>
</tr>
</tbody>
</table>
<p>We need to introduce a delay in the address as used by the translation on the
way back out, to account for the fact that read data corresponds to the address
from the previous registered cycle, not this one:</p>
<pre><code class="language-python"><span class="k">def</span> <span class="nf">translation</span><span class="p">(</span>
    <span class="n">self</span><span class="p">:</span> <span class="n">Example</span><span class="p">,</span>
    <span class="n">m</span><span class="p">:</span> <span class="n">Module</span><span class="p">,</span>
    <span class="n">rom_rd</span><span class="p">:</span> <span class="n">ReadPort</span><span class="p">,</span>
    <span class="n">rom_bus</span><span class="p">:</span> <span class="n">ROMBus</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">last_addr</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">.</span><span class="nf">like</span><span class="p">(</span><span class="n">rom_bus</span><span class="p">.</span><span class="n">addr</span><span class="p">)</span>
    <span class="n">m</span><span class="p">.</span><span class="n">d</span><span class="p">.</span><span class="n">sync</span> <span class="o">+=</span> <span class="n">last_addr</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="n">rom_bus</span><span class="p">.</span><span class="n">addr</span><span class="p">)</span>

    <span class="n">m</span><span class="p">.</span><span class="n">d</span><span class="p">.</span><span class="n">comb</span> <span class="o">+=</span> <span class="p">[</span>
        <span class="n">rom_rd</span><span class="p">.</span><span class="n">addr</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="n">rom_bus</span><span class="p">.</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">rom_bus</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="n">rom_rd</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">word_select</span><span class="p">(</span><span class="n">last_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">8</span><span class="p">)),</span>
    <span class="p">]</span>


<span class="n">Example</span><span class="p">.</span><span class="n">translation</span> <span class="o">=</span> <span class="n">translation</span></code></pre>
<p>This gives:</p>
<table>
<thead>
<tr>
<th align="right">cycle</th>
<th align="right">
<nobr>ROM bus</nobr> addr</th>
<th align="right">last <nobr>ROM bus</nobr> addr</th>
<th align="right">
<nobr>read port</nobr> data</th>
<th align="right">last <nobr>ROM bus</nobr> <nobr>addr [0]</nobr>
</th>
<th align="right">
<nobr>ROM bus</nobr> data</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">0</td>
<td align="right"><em>x</em></td>
<td align="right"><em>x</em></td>
<td align="right"><em>x</em></td>
<td align="right"><em>x</em></td>
<td align="right"><em>x</em></td>
</tr>
<tr>
<td align="right">1</td>
<td align="right"><code>0</code></td>
<td align="right"><em>x</em></td>
<td align="right"><em>x</em></td>
<td align="right"><em>x</em></td>
<td align="right"><em>x</em></td>
</tr>
<tr>
<td align="right">2</td>
<td align="right"><code>1</code></td>
<td align="right"><code>0</code></td>
<td align="right"><code>0x2211</code></td>
<td align="right"><code>0</code></td>
<td align="right"><code>0x11</code></td>
</tr>
<tr>
<td align="right">3</td>
<td align="right"><code>2</code></td>
<td align="right"><code>1</code></td>
<td align="right"><code>0x2211</code></td>
<td align="right"><code>1</code></td>
<td align="right"><code>0x22</code></td>
</tr>
<tr>
<td align="right">4</td>
<td align="right"><code>3</code></td>
<td align="right"><code>2</code></td>
<td align="right"><code>0x4433</code></td>
<td align="right"><code>0</code></td>
<td align="right"><code>0x33</code></td>
</tr>
<tr>
<td align="right">5</td>
<td align="right"><code>4</code></td>
<td align="right"><code>3</code></td>
<td align="right"><code>0x4433</code></td>
<td align="right"><code>1</code></td>
<td align="right"><code>0x44</code></td>
</tr>
</tbody>
</table>
<p>And so:</p>
<pre><code class="language-console"><span class="gp">$</span><span class="w"> </span>python <span class="nt">-c</span> <span class="s1">'import ex; ex.main()'</span>
<span class="go">data: 11
data: 22
data: 33
data: 44
data: 55
data: 66
data: 77
data: 88</span></code></pre>
<p>I like how the <em>x</em>’s in this table don’t flow back “up” in time as the data
dependencies flow right, whereas in the previous table, they do.</p>

      </main>
      <div class="sidebar">
        <div class="sidebar-inner">
          <ul>
            <li class=""><a href="./">Home</a></li>
            <li><a rel="me" href="https://kivikakk.ee">Author</a></li>
          </ul>

          
            <h2>Notes</h2>
            <ul>
              
                <li class=""><a href="0010-vyxos.html">VyxOS</a></li>
              
                <li class=""><a href="0009-time-travel-raw.html">Time travel, raw</a></li>
              
                <li class=""><a href="0008-time-travel.html">Time travel</a></li>
              
                <li class=""><a href="0007-amaranth-to-chisel.html">Amaranth to Chisel</a></li>
              
                <li class=""><a href="0006-comrak-on-akkoma.html">Comrak on Akkoma</a></li>
              
                <li class=""><a href="0005-jambalam.html">Jambalam</a></li>
              
                <li class=""><a href="0004-happy-birthday.html">Happy birthday!</a></li>
              
                <li class=""><a href="0003-nix-revisited.html">Nix revisited</a></li>
              
                <li class="active"><a href="0002-untangling-cycles.html">Untangling cycles</a></li>
              
                <li class=""><a href="0001-hdl-toolchain-source.html">Installing an HDL toolchain from source</a></li>
              
            </ul>
          

          
        </div>

        
      </div>
    </div>
    <footer>
      <p>
        Licensed under the <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>
        by its author.
      </p>
    </footer>
    <script src="toc-highlight.js"></script>
  

</body></html>