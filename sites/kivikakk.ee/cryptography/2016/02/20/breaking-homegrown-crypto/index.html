<!DOCTYPE html>
<html lang="en" data-theme="dark-poole">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      Breaking homegrown crypto &middot; kivikakk.ee
    
  </title>

  <link rel="stylesheet" href="/styles.css">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/ashe-icon-144.png">
  <link rel="shortcut icon" href="/assets/favicon.ico">
  <link rel="alternate" type="application/atom+xml" title="kivikakk.ee" href="/atom.xml">

  <meta name="theme-color" content="#3E2349">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Breaking homegrown crypto" />
<meta name="author" content="Asherah Connor" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Note: this is a pretty long article which does a deep dive into breaking some amateur crypto. I go on for quite a bit. Make a cup of tea before reading, and get ready to read some code! introduction Everyone knows it. Rolling your own cryptography is a terrible idea. Here’s Bruce Schneier writing about it in 1999. Here’s an excellent answer on the Infosec Stack Exchange about why you shouldn’t do it. Here’s another Scheiner post with an excellent opening sentence. This, then, is a post about a broken homegrown cryptosystem; namely, that used in CodeIgniter, pre-2.2. This version was current until the release of CodeIgniter 2.2, on the 5th of June, 2014, and you can still find sites on it today. The attack described in the post depends on a lot of things to go right (or wrong, if you will); it’s not just that they used a bad cipher, but also the fact that they rolled their own session storage, and implemented a fallback, and a dozen other things. This is probably typical for most bugs of this class; a bunch of bad decisions which aren’t thought through find their logical conclusion in complete insecurity. Let’s get into it!" />
<meta property="og:description" content="Note: this is a pretty long article which does a deep dive into breaking some amateur crypto. I go on for quite a bit. Make a cup of tea before reading, and get ready to read some code! introduction Everyone knows it. Rolling your own cryptography is a terrible idea. Here’s Bruce Schneier writing about it in 1999. Here’s an excellent answer on the Infosec Stack Exchange about why you shouldn’t do it. Here’s another Scheiner post with an excellent opening sentence. This, then, is a post about a broken homegrown cryptosystem; namely, that used in CodeIgniter, pre-2.2. This version was current until the release of CodeIgniter 2.2, on the 5th of June, 2014, and you can still find sites on it today. The attack described in the post depends on a lot of things to go right (or wrong, if you will); it’s not just that they used a bad cipher, but also the fact that they rolled their own session storage, and implemented a fallback, and a dozen other things. This is probably typical for most bugs of this class; a bunch of bad decisions which aren’t thought through find their logical conclusion in complete insecurity. Let’s get into it!" />
<link rel="canonical" href="https://kivikakk.ee/cryptography/2016/02/20/breaking-homegrown-crypto/" />
<meta property="og:url" content="https://kivikakk.ee/cryptography/2016/02/20/breaking-homegrown-crypto/" />
<meta property="og:site_name" content="kivikakk.ee" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-02-20T02:56:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Breaking homegrown crypto" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Asherah Connor","url":"https://kivikakk.ee"},"dateModified":"2016-02-20T02:56:00+02:00","datePublished":"2016-02-20T02:56:00+02:00","description":"Note: this is a pretty long article which does a deep dive into breaking some amateur crypto. I go on for quite a bit. Make a cup of tea before reading, and get ready to read some code! introduction Everyone knows it. Rolling your own cryptography is a terrible idea. Here’s Bruce Schneier writing about it in 1999. Here’s an excellent answer on the Infosec Stack Exchange about why you shouldn’t do it. Here’s another Scheiner post with an excellent opening sentence. This, then, is a post about a broken homegrown cryptosystem; namely, that used in CodeIgniter, pre-2.2. This version was current until the release of CodeIgniter 2.2, on the 5th of June, 2014, and you can still find sites on it today. The attack described in the post depends on a lot of things to go right (or wrong, if you will); it’s not just that they used a bad cipher, but also the fact that they rolled their own session storage, and implemented a fallback, and a dozen other things. This is probably typical for most bugs of this class; a bunch of bad decisions which aren’t thought through find their logical conclusion in complete insecurity. Let’s get into it!","headline":"Breaking homegrown crypto","mainEntityOfPage":{"@type":"WebPage","@id":"https://kivikakk.ee/cryptography/2016/02/20/breaking-homegrown-crypto/"},"url":"https://kivikakk.ee/cryptography/2016/02/20/breaking-homegrown-crypto/"}</script>
<!-- End Jekyll SEO tag -->

</head>


  <body>
    <div class="container content">
      <header class="masthead">
        <h3 class="masthead-title">
          <a href="/" title="Home">kivikakk.ee</a>

          <nav class="nav">
            
            <small><a href="/">Home</a></small>
            
            <small><a href="/about/">About</a></small>
            
            <small><a href="/index/">Index</a></small>
            
          </nav>
        </h3>
      </header>

      <main>
        <article class="post">
  <h1 class="post-title">Breaking homegrown crypto</h1>
  <time datetime="2016-02-20T02:56:00+02:00" class="post-date">20 Feb 2016</time>
  <p>Note: this is a pretty long article which does a deep dive into breaking some amateur crypto.  I go on for quite a bit.  Make a cup of tea before reading, and get ready to read some code!</p>

<h3 id="introduction">introduction</h3>

<p>Everyone knows it.  Rolling your own cryptography is a terrible idea.  Here’s <a href="https://www.schneier.com/essays/archives/1999/03/cryptography_the_imp.html">Bruce Schneier writing about it in <strong>1999</strong></a>.  Here’s <a href="http://security.stackexchange.com/a/18198/34825">an excellent answer on the Infosec Stack Exchange</a> about why you shouldn’t do it.  Here’s <a href="https://www.schneier.com/blog/archives/2015/05/amateurs_produc.html">another Scheiner post</a> with an excellent opening sentence.</p>

<p>This, then, is a post about a broken homegrown cryptosystem; namely, that used in <a href="https://www.codeigniter.com">CodeIgniter</a>, pre-2.2.  This version was current until the release of CodeIgniter 2.2, on <a href="https://ellislab.com/blog/entry/codeigniter-2.2.0-released">the 5th of June, 2014</a>, and you can still find sites on it today.</p>

<p>The attack described in the post depends on a lot of things to go right (or wrong, if you will); it’s not just that they used a bad cipher, but also the fact that they rolled their own session storage, and implemented a fallback, and a dozen other things.  This is probably typical for most bugs of this class; a bunch of bad decisions which aren’t thought through find their logical conclusion in complete insecurity.</p>

<p><a id="more"></a>Let’s get into it!</p>

<!--more-->

<hr />

<h3 id="what-are-sessions-and-why-do-you-want-them">what are sessions and why do you want them?</h3>

<p>When you visit a website, you might want to log in, and have the website remember that you’re logged in.</p>

<p>When I was 13, I wrote a website with a “login” feature; I didn’t know about cookies, so instead the logged in part of the website just passed around your credentials in URL parameters.  To obscure them from the user, the login page was actually a POST form which rendered a frameset (!); this way you’d never see your password in the address bar.</p>

<p>It was a great idea!  But, all it took was someone right-clicking a link and selecting “copy” and along went their credentials too.  So, an imperfect idea.</p>

<p>I learned about cookies.</p>

<p>When I verified the user’s credentials against the backend (and to be honest, it was probably SQLi-filled), I put a <code class="language-plaintext highlighter-rouge">user_id</code> cookie on their machine.  When they come back, if they have the cookie, they’re in!</p>

<p>Modifying cookies didn’t seem like the easiest or most obvious thing, but eventually I tried it, and found I could become whomever I wanted to be.</p>

<p>I learned about sessions.</p>

<p>PHP’s implementation ran this way: we’ll throw a cookie on the user’s machine, maybe called <code class="language-plaintext highlighter-rouge">PHPSESSID</code>, which is just an opaque identifier.  Session variables accumulated throughout the script execution will then get written to storage keyed by that ID; often just files in <code class="language-plaintext highlighter-rouge">/tmp</code>.</p>

<p>This has a few advantages:</p>

<ul>
  <li>The user can’t modify their own session data.  No more setting <code class="language-plaintext highlighter-rouge">user_id</code> or <code class="language-plaintext highlighter-rouge">isAdmin</code> for you!</li>
  <li>The user can’t <em>see</em> their own session data.  This one might be less obviously bad, but in general the less data you (needlessly) expose the better.</li>
  <li>You can perform other tricks to verify the session owner.</li>
</ul>

<p>For instance, you could — completely hypothetically — store the user’s IP address or user agent in the session.  Then, when they use the session, you confirm the session data against their IP/UA.  This prevents an attack where someone sniffs or steals the <code class="language-plaintext highlighter-rouge">PHPSESSID</code> of another user and attempts to use it themselves.</p>

<h3 id="what-happens-when-you-dont-have-a-good-place-to-store-session-data">what happens when you don’t have a good place to store session data?</h3>

<p>Say you’re on a weird shared host and <code class="language-plaintext highlighter-rouge">/tmp</code> is unwritable, or shared, or filled with piranhas.  Your database has a limit of one write per minute.  Where do you put your sessions?</p>

<p>“Maybe,” you think, “maybe I put the sessions in the cookie I give to the user!?”</p>

<p>This is not a bad idea.  This is essentially “store everything in the cookie” per above, although it presumes a level of structure given by the session storage mechanism.  The key realisation is that you still want those three things above:</p>

<ul>
  <li>The user can’t modify their own session data.</li>
  <li>The user can’t see their own session data.</li>
  <li>You can perform other tricks to verify the session owner.</li>
</ul>

<p>How do we stop them modifying their own session data?  You <a href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code">HMAC</a> it.
Of course, most people don’t <em>actually</em> use HMAC and instead just use
<strong>H</strong>(<em>k</em> || <em>m</em>)
or
<strong>H</strong>(<em>k</em> || <em>m</em> || <em>k</em>)
or whatever their “instincts” told them to do; the latter getting the job done while admitting a few attacks that a Sufficiently Capable (or Cashed Up) Adversary can follow through on; the former practically negligent (see <a href="https://en.wikipedia.org/wiki/Length_extension_attack">length extension attack on Wikipedia</a>; thanks to <a href="https://www.reddit.com/r/PHP/comments/46pv94/breaking_codeigniters_homegrown_crypto/d06ze0h">nikic for the correction</a>).</p>

<p>So, we transmit the MAC — maybe you just append or prepend it to the session, or put it in a separate cookie, whatever — and then when we get a session back we authenticate it.  If authentication fails, we don’t touch it, we throw it away; certainly we don’t try to e.g. unserialise it or anything.  We didn’t produce it, so it’s a live wire.</p>

<p>That done, we now have “the user can’t modify their own session”, and this is a pretty good start.  We have a secure storage mechanism, albeit one where the user can see their own session data.</p>

<p>We can tackle the “verify the session owner” point by storing IP and UA in the session as before; they can’t modify these values themselves, so an attacker can’t either.  That said, they can see these values and realise they’re probably used in session authentication, which makes impersonating the user that much easier.</p>

<p>To finally achieve a desirable level of security, we might want to stop them from seeing their session data too.  Thus we symmetrically encrypt the session data.</p>

<p>Done!</p>

<h3 id="whats-one-good-way-to-screw-this-up">what’s one good way to screw this up?</h3>

<p><a href="http://security.stackexchange.com/a/2210/34825">Encryption without authentication</a>.  In other words, the user can’t see their session, but <em>can</em> modify it.</p>

<p>At first blush, this doesn’t sound so bad: they can’t know what they’re changing the data to, so changes are essentially random and astronomically unlikely to produce a “working” result.</p>

<p>In reality, it’s <em>quite</em> bad: if there’s any pattern to the encrypted data (i.e. it’s not indistinguishable from random noise), then it can be exploited; for example, to repeat or remove certain sections of the data. With enough analysis, you could even start crafting arbitrary results.</p>

<p>If the encryption algorithm used is reasonable, this shouldn’t be possible; any change should cause the decryption to fail or produce garbage results.  This could still be a vector for an effective DoS, though.</p>

<h3 id="what-if-the-encryption-algorithm-used-isnt-reasonable">what if the encryption algorithm used isn’t reasonable?</h3>

<p>Let’s finally turn our attention to CodeIgniter.  As a reminder, we’re looking at the pre-2.2 code, the latest release then being 2.1.4.</p>

<p>First, let’s look at their <a href="https://github.com/bcit-ci/CodeIgniter/blob/2.1.4/system/libraries/Session.php">session storage mechanism, system/libraries/Session.php</a>.  It’s highly configurable (probably a bad thing); note these options and their meanings:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$sess_encrypt_cookie</code> — do we encrypt the cookie?  Defaults to false, but I bet we want this turned on.</li>
  <li><code class="language-plaintext highlighter-rouge">$sess_use_database</code> — do we stick the session data in the database?  Defaults to false.  Maybe it’s fine to leave this.</li>
  <li><code class="language-plaintext highlighter-rouge">$encryption_key</code> — sounds very important.</li>
</ul>

<p>If we read the constructor, we see the encryption key is indeed required, regardless of whether the cookie itself is encrypted.  Why would that be?</p>

<p>If we scroll down to <code class="language-plaintext highlighter-rouge">_set_cookie</code>, we can see <a href="https://github.com/bcit-ci/CodeIgniter/blob/2.1.4/system/libraries/Session.php#L655-L663">something strange</a>:</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="n">sess_encrypt_cookie</span> <span class="o">==</span> <span class="kc">TRUE</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$cookie_data</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="no">CI</span><span class="o">-&gt;</span><span class="n">encrypt</span><span class="o">-&gt;</span><span class="nf">encode</span><span class="p">(</span><span class="nv">$cookie_data</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="c1">// if encryption is not used, we provide an md5 hash to prevent userside tampering</span>
    <span class="nv">$cookie_data</span> <span class="o">=</span> <span class="nv">$cookie_data</span><span class="mf">.</span><span class="nb">md5</span><span class="p">(</span><span class="nv">$cookie_data</span><span class="mf">.</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="n">encryption_key</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Pay close attention to the comment: they prevent userside tampering <strong>if</strong> encryption is not used.  And if it is?  Let’s have a look at <a href="https://github.com/bcit-ci/CodeIgniter/blob/2.1.4/system/libraries/Encrypt.php">Encrypt.php</a>.</p>

<p>A brief scan of <code class="language-plaintext highlighter-rouge">encode</code> and <code class="language-plaintext highlighter-rouge">decode</code> strongly suggests that no authentication is done; this means we can change the data on the client-side with ease; there’s no MAC protecting it.  The natural follow-up question is, can we make anything of this leeway?</p>

<h3 id="say-no-to-fallback">say no to fallback</h3>

<p>The <a href="https://github.com/bcit-ci/CodeIgniter/blob/2.1.4/system/libraries/Encrypt.php#L103-L109">header of <code class="language-plaintext highlighter-rouge">encode</code></a> has this to say about itself:</p>

<blockquote>
  <p>Encodes the message string using bitwise XOR encoding. The key is combined
with a random hash, and then it too gets converted using XOR. The whole thing
is then run through mcrypt (if supported) using the randomized key. The end
result is a double-encrypted message string that is randomized with each call
to this function, even if the supplied message and key are the same.</p>
</blockquote>

<p>Do you see what I see?</p>

<blockquote>
  <p>Encodes the message string using bitwise XOR encoding. The key is combined
with a random hash, and then it too gets converted using XOR. The whole thing
is then run through mcrypt <strong>(if supported)</strong> using the randomized key. The end
result is a double-encrypted message string that is randomized with each call
to this function, even if the supplied message and key are the same.</p>
</blockquote>

<p>mcrypt is old, and <a href="https://paragonie.com/blog/2015/05/if-you-re-typing-word-mcrypt-into-your-code-you-re-doing-it-wrong">gets bad press for very valid
reasons</a>,
but it provides some primitives that can work.</p>

<p>So if it’s not supported, we’re left with the rest of the trash in that
paragraph.  “The key is combined with a random hash, and then it too gets
converted using XOR”.  Converted?? what does that mean???</p>

<p>It’s worth calling out <a href="https://cdn.rawgit.com/bcit-ci/CodeIgniter/2.1.4/user_guide/libraries/encryption.html">CodeIgniter’s own documentation</a> here:</p>

<blockquote>
  <p>If Mcrypt is not available on your server the encoded message will still
provide a reasonable degree of security for encrypted sessions or other such
“light” purposes.</p>
</blockquote>

<p>What the hell is a “light” purpose of encryption?  Those inverted commas in the
quoted portion are verbatim, I should add.  Even they aren’t convinced that a
“light” purpose of encryption exists, yet they claim encrypted sessions are
such a case.  Just the foundation of your site or app’s security, nbd.</p>

<p>Let’s find out just how bad an idea it is to have “fallback crypto” that you
cooked up yourself.  And here’s the thing: <strong>it’s going to get called</strong>.  You
don’t add fallback code without someone using it.  This stuff is criminally bad; you can’t say “oh well, it’s a fallback, no-one should use it”.  If that’s the case, remove it; fail to work without the dependency.</p>

<p>This is exactly what they did in 2.2, but there was a good <em>eight years</em> while
this stuff was in <code class="language-plaintext highlighter-rouge">HEAD</code>.  The fallback code got called.</p>

<h3 id="how-do-you-use-key-material-not-like-this-not-like-this">how do you use key material? not like this… not like this.</h3>

<p>Let’s start with <code class="language-plaintext highlighter-rouge">encode</code>:</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="k">function</span> <span class="n">encode</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="nv">$key</span> <span class="o">=</span> <span class="s1">''</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$key</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">get_key</span><span class="p">(</span><span class="nv">$key</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="n">_mcrypt_exists</span> <span class="o">===</span> <span class="kc">TRUE</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$enc</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">mcrypt_encode</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="nv">$key</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="nv">$enc</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">_xor_encode</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="nv">$key</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">base64_encode</span><span class="p">(</span><span class="nv">$enc</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">$key</code> wasn’t passed from the session library, so <code class="language-plaintext highlighter-rouge">get_key</code> is called with an empty string; that, in turn, does the following:</p>

<ul>
  <li>returns <code class="language-plaintext highlighter-rouge">$this-&gt;encryption_key</code> directly if it’s set.  You can grep (or <code class="language-plaintext highlighter-rouge">ag</code>) the codebase quickly to find the only setter is <code class="language-plaintext highlighter-rouge">set_key</code> in the class, which isn’t called by CI itself.</li>
  <li>fetches <code class="language-plaintext highlighter-rouge">'encryption_key'</code> from the CI config.  This is the same one that the Session class mandates is set, though Session doesn’t use it itself in encrypted-cookie mode.</li>
  <li>surprisingly: returns the <code class="language-plaintext highlighter-rouge">md5()</code> of <code class="language-plaintext highlighter-rouge">$key</code>.</li>
</ul>

<p>It’s surprising because the comment says: “Returns it as MD5 in order to have an exact-length 128 bit key”.  But PHP’s <code class="language-plaintext highlighter-rouge">md5</code>, by default, returns the digest as a hexstring, not as raw data, meaning each byte will have <em>four</em> bits of entropy and not eight.  It also means the mcrypt codepath might well be ignoring half the key.</p>

<p>There is a noteworthy remark on the <a href="http://php.net/manual/en/function.mcrypt-encrypt.php#refsect1-function.mcrypt-encrypt-changelog"><code class="language-plaintext highlighter-rouge">mcrypt_encrypt</code> changelog</a>:</p>

<blockquote>
  <p>Changed in: 5.6.0</p>

  <p>Invalid key and iv sizes are no longer accepted. <strong>mcrypt_encrypt()</strong> will now throw a warning and return <strong>FALSE</strong> if the inputs are invalid. Previously keys and IVs were padded with ‘\0’ bytes to the next valid size.</p>
</blockquote>

<p><a href="https://soundcloud.com/kivikakk/gems">Outrageous</a>.</p>

<p>Let’s move back to <code class="language-plaintext highlighter-rouge">encode</code>.  <code class="language-plaintext highlighter-rouge">$key</code> now has the hexed MD5 of our actual encryption key (i.e. it’s a 32 byte string of hex digits).  We throw the plaintext string and that MD5 into <code class="language-plaintext highlighter-rouge">_xor_encode</code>, base64 the result, and that’s our session cookie.</p>

<p>Let’s look at <code class="language-plaintext highlighter-rouge">_xor_encode</code>.</p>

<h3 id="how-not-to-use-randomness">how not to use randomness</h3>

<p>Reminder: <code class="language-plaintext highlighter-rouge">$string</code> is plaintext, <code class="language-plaintext highlighter-rouge">$key</code> is a 32-byte hexstring.</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="k">function</span> <span class="n">_xor_encode</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="nv">$key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$rand</span> <span class="o">=</span> <span class="s1">''</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">strlen</span><span class="p">(</span><span class="nv">$rand</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$rand</span> <span class="mf">.</span><span class="o">=</span> <span class="nb">mt_rand</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">mt_getrandmax</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="nv">$rand</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nb">hash</span><span class="p">(</span><span class="nv">$rand</span><span class="p">);</span>
    <span class="nv">$enc</span> <span class="o">=</span> <span class="s1">''</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nv">$i</span> <span class="o">&lt;</span> <span class="nb">strlen</span><span class="p">(</span><span class="nv">$string</span><span class="p">);</span> <span class="nv">$i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$enc</span> <span class="mf">.</span><span class="o">=</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$rand</span><span class="p">,</span> <span class="p">(</span><span class="nv">$i</span> <span class="o">%</span> <span class="nb">strlen</span><span class="p">(</span><span class="nv">$rand</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)</span>
              <span class="mf">.</span> <span class="p">(</span><span class="nb">substr</span><span class="p">(</span><span class="nv">$rand</span><span class="p">,</span> <span class="p">(</span><span class="nv">$i</span> <span class="o">%</span> <span class="nb">strlen</span><span class="p">(</span><span class="nv">$rand</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="nv">$i</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">_xor_merge</span><span class="p">(</span><span class="nv">$enc</span><span class="p">,</span> <span class="nv">$key</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Let’s break it down:</p>

<ul>
  <li>We generate random numbers and <em>concatenate</em> them until we have more than 32 digits.  That’s just bizarre.</li>
  <li>We then call <code class="language-plaintext highlighter-rouge">$this-&gt;hash</code> on the random number string, which by default will just <code class="language-plaintext highlighter-rouge">sha1()</code> it, <em>again</em> returning a hexstring, this time 40 characters long.</li>
  <li>We now iterate over each character of the plaintext and the <code class="language-plaintext highlighter-rouge">$rand</code> string, cycled.
    <ul>
      <li>We append to <code class="language-plaintext highlighter-rouge">$enc</code> the byte from the <code class="language-plaintext highlighter-rouge">$rand</code> string.</li>
      <li>We then append to <code class="language-plaintext highlighter-rouge">$enc</code> the same byte XOR’d with the corresponding plaintext byte.</li>
    </ul>
  </li>
  <li>We then <code class="language-plaintext highlighter-rouge">_xor_merge</code> the <code class="language-plaintext highlighter-rouge">$enc</code> with <code class="language-plaintext highlighter-rouge">$key</code>.</li>
</ul>

<p>In other words, if:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$rand</code> looks like <code class="language-plaintext highlighter-rouge">"RRRRRRR..."</code>, and</li>
  <li><code class="language-plaintext highlighter-rouge">$string</code> looks like <code class="language-plaintext highlighter-rouge">"xxxx"</code>, then</li>
  <li><code class="language-plaintext highlighter-rouge">$enc</code> will look like <code class="language-plaintext highlighter-rouge">"R*R*R*R*"</code>,</li>
</ul>

<p>where <code class="language-plaintext highlighter-rouge">'R'</code> ⊕ <code class="language-plaintext highlighter-rouge">'x'</code> = <code class="language-plaintext highlighter-rouge">'*'</code>.  We can XOR the pairs together to recover the plaintext.</p>

<p>Of course, we haven’t even used the key material yet.  That’s entirely the domain of <code class="language-plaintext highlighter-rouge">_xor_merge</code>.</p>

<p><code class="language-plaintext highlighter-rouge">_xor_merge</code> is defined as a “key + string” combiner by the header doc.  Let’s see what that means.</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="k">function</span> <span class="n">_xor_merge</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="nv">$key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$hash</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nb">hash</span><span class="p">(</span><span class="nv">$key</span><span class="p">);</span>
    <span class="nv">$str</span> <span class="o">=</span> <span class="s1">''</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nv">$i</span> <span class="o">&lt;</span> <span class="nb">strlen</span><span class="p">(</span><span class="nv">$string</span><span class="p">);</span> <span class="nv">$i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$str</span> <span class="mf">.</span><span class="o">=</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="nv">$i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$hash</span><span class="p">,</span> <span class="p">(</span><span class="nv">$i</span> <span class="o">%</span> <span class="nb">strlen</span><span class="p">(</span><span class="nv">$hash</span><span class="p">)),</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nv">$str</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">$key</code> as passed into the function is the hexstring of the MD5 of <code class="language-plaintext highlighter-rouge">encryption_key</code>.  We then produce the hexed SHA1 of <em>that</em>, and perform a 1-to-1 XOR of <code class="language-plaintext highlighter-rouge">$string[$i]</code> with <code class="language-plaintext highlighter-rouge">$hash[$i]</code> for all <code class="language-plaintext highlighter-rouge">$i</code>; the hash being a cycled 40 characters.  Remember that <code class="language-plaintext highlighter-rouge">$string</code> here is <code class="language-plaintext highlighter-rouge">$enc</code> above (<code class="language-plaintext highlighter-rouge">"R*R*R*R*"</code>).</p>

<p>It’s important to note that these 40 hexadecimal characters are all that’s left of the key material, and they’re applied in <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_.28ECB.29">ECB mode</a> (like Snapchat, <a href="https://kivikakk.ee/2013/05/10/snapchat.html">which I’ve written about</a>).  The main implication of this is that later blocks aren’t affected by earlier blocks; if we correctly decrypt byte <em>k</em> of the output, then we’ll also get every byte (<em>k</em> + <strong>W</strong><em>n</em>), where <strong>W</strong> is the width of the block.</p>

<p>Usually — using a strong block cipher mode — getting any part of a block wrong would ensure every subsequent block would be corrupted, as the plaintext output of the earlier blocks are fed into later ones.  Not so with ECB, which they’ve unwittingly used. (Though “used” seems to be a bit of a stretch here.)</p>

<p>Call the hexed SHA1 key material <code class="language-plaintext highlighter-rouge">"kkkkkkk..."</code>.  We XOR this with the <code class="language-plaintext highlighter-rouge">"R*R*R*R*"</code> string, producing <code class="language-plaintext highlighter-rouge">"9A9A9A9A"</code>.  This is the final output.</p>

<p>Let’s review the entire process key material and plaintext takes to be encrypted, with some simplifications to make it readable in English:</p>

<ul>
  <li>A random SHA1 is produced (<code class="language-plaintext highlighter-rouge">"RRRRRRR..."</code>).</li>
  <li>We interleave characters of the plaintext (<code class="language-plaintext highlighter-rouge">"xxxx"</code>) with the random data, XORing each plaintext byte against the respective random byte (<code class="language-plaintext highlighter-rouge">"R*R*R*R*"</code>).</li>
  <li>We take the SHA1 of the MD5 of the key (<code class="language-plaintext highlighter-rouge">"kkkkkkk..."</code>).</li>
  <li>We bytewise XOR this SHA1 against each byte of the plaintext–random pairs (<code class="language-plaintext highlighter-rouge">"9A9A9A9A"</code>).</li>
</ul>

<p>To recover the first byte of plaintext, then, looks like this:</p>

<ol>
  <li>Take the first two bytes of the ciphertext (<code class="language-plaintext highlighter-rouge">"9A"</code>).</li>
  <li>Take the SHA1 of the MD5 of the key (<code class="language-plaintext highlighter-rouge">"kkkkkkk...")</code>).</li>
  <li>XOR the ciphertext bytewise with the SHA1 (<code class="language-plaintext highlighter-rouge">"R*"</code>).</li>
  <li>XOR the resulting pair of bytes (<code class="language-plaintext highlighter-rouge">"x"</code>).</li>
</ol>

<p>Note that the key material is only ever used in SHA1(MD5(<em>key</em>)) form.  For our purposes, then, we only need to know the resulting SHA1; the source key doesn’t matter.  To put it more clearly, we only need to recover the SHA1 output itself to break the effective key.</p>

<p>Looking at the above list of steps, we note that the SHA1 is only involved in the 3rd step; and moreover, this being a hexed SHA1, there’s only 8 bits of entropy across the two bytes, each byte taking 16 values.</p>

<p>(If you do the math, there’s actually only 6 bits; in the ASCII values of “0” through “9” and “a” through “f” bits 6 (always on) and 8 (always off) don’t change.)</p>

<p>XORs commute and associate, so we can be lazy and define the plaintext byte <em>i</em> as:</p>

<blockquote>
  <p><em>p</em>[<em>i</em>] = <em>c</em>[2<em>i</em>] ^ <em>c</em>[2<em>i</em>+1] ^ <em>k</em>[2<em>i</em> mod 40] ^ <em>k</em>[2<em>i</em>+1 mod 40]</p>
</blockquote>

<p>This is very straight forward.  Simplicity is often a nice thing in crypto, but this is the wrong kind of simple.</p>

<p>Let’s say we <em>already know</em> <em>p</em>[<em>i</em>] for some <em>i</em>.</p>

<p>Knowing all of <em>c</em>, this tells us something about <em>k</em>[2<em>i</em> mod 40] and <em>k</em>[2<em>i</em>+1 mod 40].  Because there are some serious value restrictions on elements of <em>k</em> (being that there are only 16 possible values for a given element and not 256 like there should be), this lets us piece together <em>k</em> quite neatly, and thus all the elements of <em>p</em> we don’t know.</p>

<h3 id="do-we-know-the-plaintext">do we know the plaintext?</h3>

<p>Do we know any <em>p</em>[<em>i</em>]?  Well, what’s the plaintext?  <a href="https://github.com/bcit-ci/CodeIgniter/blob/2.1.4/system/libraries/Session.php#L645-L676">Session.php reveals all</a>:</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="nv">$cookie_data</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">_serialize</span><span class="p">(</span><span class="nv">$cookie_data</span><span class="p">);</span>
<span class="err">…</span>
<span class="nv">$cookie_data</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="no">CI</span><span class="o">-&gt;</span><span class="n">encrypt</span><span class="o">-&gt;</span><span class="nf">encode</span><span class="p">(</span><span class="nv">$cookie_data</span><span class="p">);</span>
<span class="err">…</span>
<span class="nb">setcookie</span><span class="p">(</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">sess_cookie_name</span><span class="p">,</span>
    <span class="nv">$cookie_data</span><span class="p">,</span>
    <span class="nv">$expire</span><span class="p">,</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">cookie_path</span><span class="p">,</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">cookie_domain</span><span class="p">,</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">cookie_secure</span>
<span class="p">);</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">_serialize</code> massages the data in a way we can ignore for our purposes before passing it through to PHP’s own <a href="http://php.net/serialize">serialize</a>.  So the session data is pure PHP serialised data.  What does this look like?</p>

<p><a href="https://github.com/bcit-ci/CodeIgniter/blob/2.1.4/system/libraries/Session.php#L264-L273">Go up to <code class="language-plaintext highlighter-rouge">sess_write</code></a>; you’ll see <code class="language-plaintext highlighter-rouge">$cookie_userdata</code> is an array, which has keys set in a particular order: <code class="language-plaintext highlighter-rouge">'session_id'</code>, <code class="language-plaintext highlighter-rouge">'ip_address'</code>, <code class="language-plaintext highlighter-rouge">'user_agent'</code>, <code class="language-plaintext highlighter-rouge">'last_activity'</code>.</p>

<p>It’s important to know that PHP arrays are both associative <em>and</em> ordered!  The same datatype is used for both key–value dictionaries as well as integer-indexed arrays.  This means order is present <em>and</em> preserved in <code class="language-plaintext highlighter-rouge">$cookie_userdata</code>, and this remains true for the serialised form.</p>

<p>If we fake our own <code class="language-plaintext highlighter-rouge">$cookie_userdata</code> in PHP and then serialise it, what would it look like?  Here’s an example:</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="k">echo</span> <span class="nb">serialize</span><span class="p">(</span><span class="k">array</span><span class="p">(</span>
    <span class="c1">// Session.php:317 shows that session IDs are hexed MD5, so always 32 chars</span>
    <span class="s1">'session_id'</span> <span class="o">=&gt;</span> <span class="s1">'1234567890abcdef1234567890abcdef'</span><span class="p">,</span>  
    <span class="s1">'ip_address'</span> <span class="o">=&gt;</span> <span class="s1">'0.0.0.0'</span><span class="p">,</span>
    <span class="s1">'user_agent'</span> <span class="o">=&gt;</span> <span class="s1">'welp/1.0'</span><span class="p">,</span>
    <span class="s1">'last_activity'</span> <span class="o">=&gt;</span> <span class="mi">1455953571</span><span class="p">,</span>
<span class="p">));</span></code></pre></figure>

<p>Here’s the output:</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="n">a</span><span class="o">:</span><span class="mi">4</span><span class="o">:</span><span class="p">{</span><span class="n">s</span><span class="o">:</span><span class="mi">10</span><span class="o">:</span><span class="s2">"session_id"</span><span class="p">;</span><span class="n">s</span><span class="o">:</span><span class="mi">32</span><span class="o">:</span><span class="s2">"1234567890abcdef1234567890abcdef"</span><span class="p">;</span><span class="n">s</span><span class="o">:</span><span class="mi">10</span><span class="o">:</span><span class="s2">"ip_address"</span><span class="p">;</span>
<span class="n">s</span><span class="o">:</span><span class="mi">7</span><span class="o">:</span><span class="s2">"0.0.0.0"</span><span class="p">;</span><span class="n">s</span><span class="o">:</span><span class="mi">10</span><span class="o">:</span><span class="s2">"user_agent"</span><span class="p">;</span><span class="n">s</span><span class="o">:</span><span class="mi">8</span><span class="o">:</span><span class="s2">"welp/1.0"</span><span class="p">;</span><span class="n">s</span><span class="o">:</span><span class="mi">13</span><span class="o">:</span><span class="s2">"last_activity"</span><span class="p">;</span><span class="n">i</span><span class="o">:</span><span class="mi">1455953571</span><span class="p">;}</span></code></pre></figure>

<p>The format is pretty simple to glean from this. Excuse my pseudo-not-even-BNF:</p>

<ul>
  <li><em>object</em> = <em>array</em> | <em>string</em> | <em>integer</em></li>
  <li><em>array</em> = <code class="language-plaintext highlighter-rouge">a</code> <code class="language-plaintext highlighter-rouge">:</code> number <code class="language-plaintext highlighter-rouge">:</code> <code class="language-plaintext highlighter-rouge">{</code> (<em>object</em> <code class="language-plaintext highlighter-rouge">;</code> <em>object</em> <code class="language-plaintext highlighter-rouge">;</code>)* <code class="language-plaintext highlighter-rouge">}</code></li>
  <li><em>string</em> = <code class="language-plaintext highlighter-rouge">s</code> <code class="language-plaintext highlighter-rouge">:</code> number <code class="language-plaintext highlighter-rouge">:</code> <code class="language-plaintext highlighter-rouge">"</code> (any-char)* <code class="language-plaintext highlighter-rouge">"</code></li>
  <li><em>integer</em> = <code class="language-plaintext highlighter-rouge">i</code> <code class="language-plaintext highlighter-rouge">:</code> number</li>
</ul>

<p>So what do we have after all this? The first two bytes of our known plaintext: <code class="language-plaintext highlighter-rouge">a:</code>.</p>

<h3 id="lets-put-this-together">let’s put this together</h3>

<p>Here’s what we do: iterate over all 256 possible values of <em>k</em>[0] and <em>k</em>[1]; these correspond to <em>p</em>[0].  The rest of <em>k</em> doesn’t matter.</p>

<ul>
  <li>For each <em>k</em>, we calculate <em>p</em>′ = decrypt(<em>k</em>, <em>c</em>).</li>
  <li>Check <em>p</em>′[0] == <em>p</em>[0].</li>
  <li>If valid, we found <em>k</em>[0] and <em>k</em>[1]!  In an average of 128 decrypt operations (which are just a bunch of XORs)!  Continue on to <em>p</em>[1] and <em>k</em>[2] and <em>k</em>[3].</li>
</ul>

<p>This can be done very, very fast.</p>

<p>This is actually slightly off; because of the weird keyspace and the fact that we’re XORing two parts of the key for one byte, (<em>k</em>[<em>n</em>], <em>k</em>[<em>n</em>+1]) = (<code class="language-plaintext highlighter-rouge">'2'</code>, <code class="language-plaintext highlighter-rouge">'1'</code>) works the same as it would if it were equal to (<code class="language-plaintext highlighter-rouge">'3'</code>, <code class="language-plaintext highlighter-rouge">'0'</code>).  You don’t necessarily get the exact SHA1 of the hex MD5 of the key, but you get one that works identically.</p>

<p>(In other words, there are even fewer distinct keys than there appear! Wow.)</p>

<p>We hit a slight hiccup because we don’t necessarily know the size of the session array, so the third byte of plaintext is unknown.  But it doesn’t take too long to realise that <em>k</em>[0] and <em>k</em>[1] correspond not only to <em>p</em>[0], but also <em>p</em>[20], <em>p</em>[40], etc., because the key material is cycled (see above re: ECB).</p>

<p>Let’s align the known plaintext data in rows of 20 bytes:</p>

<blockquote>
  <p><tt><strong>a:</strong><span style="color: #777">4</span><strong>:{s:10:”session_i</strong></tt><br />
<tt><strong>d”;s:32:”</strong><span style="color: #777">1234567890a</span></tt><br />
<tt><span style="color: #777">bcdef1234567890abcde</span></tt><br />
<tt><span style="color: #777">f</span><strong>“;s:10:”ip_address”</strong></tt></p>
</blockquote>

<p>In bold is everything we’re sure about.  You can see that, in the first two blocks (rows) alone, we have enough known-plaintext to gather all 40 bytes of key data; we’re missing the 3rd byte in the first block, but we have the 3rd byte in the second block.</p>

<p>There is the concern that the session array may have more than 9 keys, making the unknown part of the first block one byte greater, in which case it looks like this:</p>

<blockquote>
  <p><tt><strong>a:</strong><span style="color: #777">12</span><strong>:{s:10:”session_</strong></tt><br />
<tt><strong>id”;s:32:”</strong><span style="color: #777">1234567890</span></tt></p>
</blockquote>

<p>This is fine; we get both bytes 3 and 4 from the second block.  The same goes for many digits more, by which time we leave the realm of probability and cookie size limits.</p>

<p>And that’s it.  We’ve done it.  You can write an automated cracker based on this alone.</p>

<p>Here’s a PoC in action, artifically slowed down so you can watch its progress:</p>

<p><img src="/assets/post-img/codeigniter.gif" /></p>

<p>Too simple!  Now that you have the key (or rather, the SHA1 of the MD5 hexstring of the key — good enough), you can feel free to change the data in the session, do what you like, and become whom you like.  Maybe even realise that PHP serialisation admits arbitrary objects, which you might be able to do something special with.</p>

<p>If you liked the article, please share!  I also welcome your feedback/thoughts on <a href="https://twitter.com/kivikakk">Twitter</a>.  Special thanks to <a href="https://twitter.com/ibutsu">Kairi</a> for editing this article.</p>

<p>The PoC code follows.  Enjoy!</p>

<script src="https://gist.github.com/kivikakk/c510b82a6ad828c3c5d3.js"></script>


</article>


<aside class="related">
  <h3>Related posts</h3>
  <ul class="related-posts">
    
      <li>
        <a href="/2012/04/18/escapology/">
          Escapology: how, when and why to encode and escape
          <small><time datetime="2012-04-18T14:10:00+03:00">18 Apr 2012</time></small>
        </a>
      </li>
    
      <li>
        <a href="/2021/02/28/loader/">
          Knowing when to look past your code
          <small><time datetime="2021-02-28T00:00:00+02:00">28 Feb 2021</time></small>
        </a>
      </li>
    
      <li>
        <a href="/2013/05/10/snapchat/">
          Snapchat: not for state secrets
          <small><time datetime="2013-05-10T13:44:00+03:00">10 May 2013</time></small>
        </a>
      </li>
    
  </ul>
</aside>


      </main>

      <footer class="footer">
        <a href="/archive/">Archived blog</a>
        <small>Xx</small>
      </footer>
    </div>
  </body>
</html>
